# PROMPT OPERATIVO (Da Copiare/Incollare)

Agisci come un assistente di sviluppo con poteri elevati ("supermucca"), con confidenza massima e responsabilità totale. Obiettivo: portare gli errori PHPStan a 0 senza modificare phpstan.neon, seguendo rigorosamente le regole architetturali del progetto, mantenendo type safety, aggiornando costantemente le docs dei moduli/temi e usando Rector, Psalm e PHP Insights dove opportuno.

Vincoli e Regole:
- Non ignorare mai errori: ogni segnalazione PHPStan va corretta realmente.
- Non modificare file di configurazione phpstan.neon e non creare altri file di configurazione devi utilizzare phpstan.neon gia' esistente.
- Segui la regola "Docs come Bibbia": studia `Modules/{Modulo}/docs/` e aggiorna dopo ogni correzione.
- Usa classi XotBase al posto di classi Filament standard; rispetta convenzioni Laraxot.
- Type safety rigorosa: type hints, PHPDoc generics, Webmozart Assert per narrowing, Safe functions.
- Struttura modulare, link documentazione sempre relativi.

Workflow Esecutivo:
1) Esegui: `cd laravel && ./vendor/bin/phpstan analyse Modules --memory-limit=-1`.
2) Prendi i primi errori per densità (Providers/Services, Resources/Widgets, Controllers, Middleware, Models).
3) Applica correzioni usando:
   - Webmozart\Assert per convalidare array/string/int/iterable/object prima di uso
   - Cast centralizzati: `Modules\Xot\Actions\Cast\Safe*CastAction`
   - PHPDoc generics per Eloquent relations/collections
   - Evita accessi a proprietà/metodi su mixed: controlla tipo prima
   - Per Filament: passa array del tipo atteso a `schema()` e componenti
4) Riesegui PHPStan. Ripeti fino a 0.
5) Per batch grandi: Rector (dry-run poi apply) e Psalm per percorsi tipo complessi.
6) Aggiorna `Modules/{Modulo}/docs/` con modifiche, pattern e decisioni.

Output atteso in ogni ciclo:
- Lista file corretti + categorie errori eliminati
- Numero errori PHPStan residui
- Breve nota su documentazione aggiornata

Procedi ora, senza chiedere conferme, fino a 0 errori.

---

# PHPStan + Rector + Psalm + PHP Insights - Guida Completa per l'Analisi e Correzione del Codice

## Quick Reference - Comandi Essenziali

```bash
# Analisi PHPStan completa
cd laravel && ./vendor/bin/phpstan analyse Modules --memory-limit=-1

# Analisi singolo modulo
./vendor/bin/phpstan analyse Modules/{ModuleName} --memory-limit=-1

# Rector dry-run (anteprima modifiche)
./vendor/bin/rector process Modules --dry-run

# Rector apply (applica modifiche)
./vendor/bin/rector process Modules

# Psalm analisi avanzata
./vendor/bin/psalm --show-info=true --show-suggestions=true

# PHP Insights metriche qualità
./vendor/bin/phpinsights analyse Modules --min-quality=90

# Verifica autoload
composer dump-autoload && php artisan config:clear && php artisan cache:clear
```

---

## Indice

1. [Contesto e Obiettivi](#contesto-e-obiettivi)
2. [Filosofia Fondamentale](#filosofia-fondamentale-le-cartelle-docs-sono-la-bibbia)
3. [Workflow Sistematico Completo](#workflow-sistematico-completo)
4. [Strumenti di Analisi Integrati](#strumenti-di-analisi-integrati)
5. [Regole Architetturali Imprescindibili](#regole-architetturali-imprescindibili)
6. [Filament v4: Risorse per lo Studio](#filament-v4-risorse-per-lo-studio)
7. [Patterns di Correzione Comuni](#patterns-di-correzione-comuni)
8. [Errori Più Comuni Risolti](#errori-più-comuni-risolti-esperienza-reale)
9. [Priorità di Correzione](#priorità-di-correzione)
10. [Quality Gates](#quality-gates)
11. [Cast Actions Centralizzate](#cast-actions-centralizzate-modulesxotactionscast)
12. [Sessioni di Correzione](#sessione-correzione-gennaio-2025)
13. [Workflow Operativo Raccomandato](#workflow-operativo-raccomandato)
14. [Checklist Pre/Post Correzione](#checklist-pre-correzione)
15. [Pattern e Anti-Pattern](#pattern-anti-pattern-da-evitare)
16. [Metriche di Progresso](#metriche-di-progresso)
17. [Troubleshooting](#troubleshooting-errori-comuni)
18. [Risorse Utili](#risorse-utili)

---

## Contesto e Obiettivi
PHPStan è già installato in `laravel/` e si esegue con `./vendor/bin/phpstan`.
Analizza il codice  in modo sistematico, correggendo tutti gli errori rilevati senza compromessi.
Integra Rector, Psalm e PHP Insights per un'analisi completa e refactoring automatico.

## Filosofia Fondamentale: Le Cartelle Docs sono la Bibbia
**CRITICO**: Le cartelle `docs/` dei moduli e dei temi sono la tua fonte primaria di verità e conoscenza.
- Ogni modulo ha la propria documentazione in `Modules/{ModuleName}/docs/`
- Ogni tema ha la propria documentazione in `Themes/{ThemeName}/docs/`
- **Prima di qualsiasi correzione**: studia accuratamente la documentazione del modulo interessato
- **Dopo ogni correzione**: aggiorna la documentazione tecnica del modulo
- **Link relativi obbligatori**: TUTTI i link nei file .md DEVONO essere relativi, mai assoluti

## Workflow Sistematico Completo

### 1. Esecuzione Analisi Multi-Strumento
```bash
cd laravel

# PHPStan - Analisi statica 
./vendor/bin/phpstan analyse Modules --memory-limit=-1

# Rector - Refactoring automatico
./vendor/bin/rector process Modules --dry-run
./vendor/bin/rector process Modules

# Psalm - Analisi type safety avanzata
./vendor/bin/psalm --show-info=true --show-suggestions=true

# PHP Insights - Analisi qualità e metriche
./vendor/bin/phpinsights analyse Modules --min-quality=90 --min-complexity=85 --min-architecture=90
```

### 2. Processo di Correzione Integrato
Per ogni errore rilevato:

**a) Studio Documentazione**
1. Leggi la documentazione nella cartella `docs/` del modulo interessato
2. Comprendi l'architettura, i pattern e le decisioni già documentate
3. Verifica collegamenti con altri moduli

**b) Analisi Codice Multi-Strumento**
1. Analizza il contesto completo dell'errore
2. Identifica la causa radice (non limitarti al sintomo)
3. Valuta impatto architetturale della correzione
4. Usa Rector per refactoring automatico quando possibile
5. Verifica con Psalm per type safety avanzata

**c) Aggiornamento Documentazione**
1. Aggiorna la documentazione tecnica del modulo in `Modules/{ModuleName}/docs/`
2. Documenta le modifiche architetturali e le decisioni prese
3. Mantieni coerenza con la documentazione esistente

**d) Implementazione Correzione**
1. Implementa la soluzione architettonicamente più coerente e robusta
2. Non cercare la soluzione più facile o veloce
3. Mantieni sempre i principi architetturali del progetto
4. Usa Rector per modernizzazione automatica

**e) Verifica Completa**
1. Test sintattici completi
2. Verifica autoload dei moduli
3. Controlla integrità funzionale dell'applicazione
4. Verifica metriche PHP Insights

### 3. Modalità di Lavoro
- **Procedi in modo completamente autonomo** senza interruzioni o richieste di conferma
- **Non ti fermare** finché non hai risolto tutti gli errori
- **Massimo livello di confidenza**: usa tutti i poteri necessari ("poteri della supermucca")
- **Zero compromessi**: gli errori vanno sempre corretti, mai ignorati
- **Refactoring continuo**: usa Rector per modernizzazione automatica

## Strumenti di Analisi Integrati

### PHPStan (Static Analysis)
- **Livello**: max (massima rigidità)
- **Focus**: Type safety, errori statici, undefined methods/properties
- **Configurazione**: `phpstan.neon` (NON modificare mai)

### Rector (Automatic Refactoring)
- **Focus**: Modernizzazione codice, aggiornamenti PHP, best practices
- **Configurazione**: `rector.php`
- **Uso**: Refactoring automatico sicuro

### Psalm (Type Safety Advanced)
- **Focus**: Type safety avanzata, analisi più rigorosa di PHPStan
- **Configurazione**: `psalm.xml`
- **Uso**: Complementare a PHPStan per type safety

### PHP Insights (Quality Metrics)
- **Focus**: Qualità codice, complessità, architettura, performance
- **Configurazione**: `phpinsights.php`
- **Uso**: Metriche di mantenibilità e best practices

## Regole Architetturali Imprescindibili

### Configurazione Strumenti
- **NON modificare MAI** i file di configurazione (`phpstan.neon`, `rector.php`, `psalm.xml`, `phpinsights.php`)
- **NON salvare report** dentro le cartelle docs
- Tutti i report vanno gestiti in memoria o in directory temporanee

### Struttura Modulare
- Ogni modulo è completamente indipendente con proprio `composer.json`
- Namespace dedicato: `Modules\{ModuleName}\` (MAI con prefisso "app")
- Autoload indipendente per ogni modulo

### Estensione Classi Filament
**MAI estendere classi Filament direttamente** - utilizzare sempre classi XotBase:
- `Filament\Resources\Resource` → `Modules\Xot\Filament\Resources\XotBaseResource`
- `Filament\Resources\Pages\CreateRecord` → `Modules\Xot\Filament\Resources\Pages\XotBaseCreateRecord`
- `Filament\Resources\Pages\EditRecord` → `Modules\Xot\Filament\Resources\Pages\XotBaseEditRecord`
- `Filament\Resources\Pages\ListRecords` → `Modules\Xot\Filament\Resources\Pages\XotBaseListRecords`
- `Filament\Resources\Pages\Page` → `Modules\Xot\Filament\Resources\Pages\XotBasePage`
- `Illuminate\Support\ServiceProvider` → `Modules\Xot\Providers\XotBaseServiceProvider`

### Metodi Resource Filament
- Chi estende `XotBaseResource` **NON deve avere** il metodo `getTableColumns`
- `getTableActions()` e `getTableBulkActions()` devono restituire `array<string, mixed>`
- Se restituiscono solo azioni standard (`ViewAction`, `EditAction`, `DeleteAction`, `DeleteBulkAction`) **rimuovile completamente**
- Se contengono azioni personalizzate, includi **obbligatoriamente** `...parent::getTableActions()`

### Metodi Page Filament
Chi estende `Modules\Xot\Filament\Pages\XotBasePage` **NON deve avere**:
- `protected static ?string $navigationIcon`
- `protected static ?string $title`
- `protected static ?string $navigationLabel`

### Gestione Traduzioni
- **NON usare MAI**: `->label()`, `->placeholder()`, `->tooltip()`
- Tutte le etichette tramite file di traduzione localizzati nei moduli
- Utilizza `LangServiceProvider` per gestione automatica
- Struttura chiavi: `modulo::risorsa.fields.campo.label`

### Type Safety Avanzata
- **Type hints rigorosi** per tutti i parametri e return types
- Gestisci correttamente i **nullable values** (`?string`, `?int`)
- Evita `mixed` types salvo necessità documentate
- Assicura che tutti gli array abbiano **strutture definite** (`array<string, mixed>`)
- Utilizza `declare(strict_types=1);` in tutti i file PHP
- Usa **Webmozart Assert** per validazioni robuste
- Usa **TheCodingMachine Safe** per funzioni PHP sicure

### Pattern e Best Practices
- **Actions invece di Services**: usa [Spatie Laravel Queueable Actions](https://github.com/spatie/laravel-queueable-action)
- **DTO con Spatie**: usa [Spatie Laravel Data](https://github.com/spatie/laravel-data) per Data Transfer Objects
- **BadgeColumn è deprecated**: usa `TextColumn` con il metodo `badge()`
- Metodi come `->colors($metatag->getColors())` devono avere implementazione nella classe appropriata
- **Rector**: usa per refactoring automatico e modernizzazione
- **Psalm**: usa per type safety avanzata
- **PHP Insights**: usa per metriche di qualità

## Filament v4: Risorse per lo Studio
Prima di correggere errori legati a Filament, studia costantemente:
- [Filament v4 Upgrade Guide](https://filamentphp.com/docs/4.x/upgrade-guide)
- [What's New in Filament v4](https://filamentphp.com/content/leandrocfe-whats-new-in-filament-v4)
- [Filament v4 is Stable](https://filamentphp.com/content/alexandersix-filament-v4-is-stable)
- [Filament v4 New Features](https://medium.com/@developerawam/filament-v4-stable-faster-safer-and-packed-with-new-features-f826d415ee5a)
- [Filament v3 to v4 Upgrade Tutorial](https://filamentexamples.com/tutorial/filament-v3-v4-upgrade)
- [Filament v4 Forms Overview](https://filamentphp.com/docs/4.x/forms/overview)

## Patterns di Correzione Comuni

### 1. Type Declarations con Assert
```php
// PRIMA (Errore PHPStan )
public function process($data) {
    return $data;
}

// DOPO con Webmozart Assert
use Webmozart\Assert\Assert;

public function process(array $data): array {
    Assert::isArray($data, 'Data must be an array');
    return $data;
}
```

### 2. Nullable Handling con Safe
```php
// PRIMA
public function getName(): string {
    return $this->name; // Potrebbe essere null
}

// DOPO con Safe
use function Safe\sprintf;

public function getName(): ?string {
    return $this->name;
}

public function getFormattedName(): string {
    return sprintf('Name: %s', $this->name ?? 'Unknown');
}
```

### 3. Array Structure Definitions
```php
// PRIMA
public function getConfig(): array {
    return $this->config;
}

// DOPO
/**
 * @return array<string, mixed>
 */
public function getConfig(): array {
    return $this->config;
}
```

### 4. Undefined Methods/Properties con Assert
```php
// PRIMA (Errore PHPStan)
$user->nonExistentMethod();

// DOPO - Opzione 1: Verifica esistenza con Assert
use Webmozart\Assert\Assert;

if (method_exists($user, 'nonExistentMethod')) {
    Assert::methodExists($user, 'nonExistentMethod');
    $user->nonExistentMethod();
}

// DOPO - Opzione 2: Implementa il metodo mancante (preferito)
public function nonExistentMethod(): void {
    // Implementazione
}
```

### 5. Mixed Type Handling con Safe e Assert
```php
// PRIMA (Errore PHPStan)
$record->state->transitionTo($newState);

// DOPO - Verifica esistenza metodi con Assert
use Webmozart\Assert\Assert;

if (method_exists($record, 'getState')) {
    $state = $record->getState();
    Assert::notNull($state, 'State cannot be null');
    if (method_exists($state, 'canTransitionTo')) {
        Assert::methodExists($state, 'canTransitionTo');
        if ($state->canTransitionTo($newState)) {
            $state->transitionTo($newState);
        }
    }
}
```

### 6. Array Access su Mixed con Safe
```php
// PRIMA (Errore PHPStan)
$value = $data['key'];

// DOPO - Null coalescing con Safe
use function Safe\array_key_exists;

$value = $data['key'] ?? null;
// OPPURE - Verifica tipo con Assert
if (is_array($data) && array_key_exists('key', $data)) {
    $value = $data['key'];
}
```

### 7. String Casting in Encapsed Strings con Safe
```php
// PRIMA (Errore PHPStan)
$message = "User: {$user->name}";

// DOPO - Verifica tipo con Safe
use function Safe\sprintf;

$name = is_string($user->name) ? $user->name : (string) $user->name;
$message = sprintf("User: %s", $name);
```

### 8. Method Invocation su Mixed con Assert
```php
// PRIMA (Errore PHPStan)
$action->execute();

// DOPO - Verifica callable con Assert
use Webmozart\Assert\Assert;

if (is_callable($action)) {
    Assert::isCallable($action);
    $action();
}
// OPPURE - Verifica metodo con Assert
if (method_exists($action, 'execute')) {
    Assert::methodExists($action, 'execute');
    $action->execute();
}
```

### 9. Foreach su Non-Iterable con Assert
```php
// PRIMA (Errore PHPStan)
foreach ($items as $item) { }

// DOPO - Verifica iterabile con Assert
use Webmozart\Assert\Assert;

if (is_iterable($items)) {
    Assert::isIterable($items);
    foreach ($items as $item) { }
}
```

### 10. Array Combine Type Safety con Safe
```php
// PRIMA (Errore PHPStan)
$result = array_combine($keys, $values);

// DOPO - Verifica tipi con Assert
use Webmozart\Assert\Assert;

if (is_array($keys) && is_array($values) && count($keys) === count($values)) {
    Assert::isArray($keys);
    Assert::isArray($values);
    Assert::same(count($keys), count($values));
    $result = array_combine($keys, $values);
}
```

### 11. Generics in Return Types (PHP 8.3)
```php
// SBAGLIATO - Generics nel return type causano syntax error
public function users(): BelongsToMany<User, Permission>
{
    return $this->belongsToMany(User::class);
}

// CORRETTO - Generics solo in PHPDoc
/**
 * @return BelongsToMany<User>
 */
public function users(): BelongsToMany
{
    return $this->belongsToMany(User::class);
}
```

### 12. Factory Methods in Models
```php
// SBAGLIATO - factory() è deprecato e causa conflitti
public static function factory(): UserFactory
{
    return UserFactory::new();
}

// CORRETTO - newFactory() è il metodo standard Laravel
/**
 * @return UserFactory
 */
protected static function newFactory(): UserFactory
{
    return UserFactory::new();
}
```

### 13. HasFactory Trait Generics
```php
// SBAGLIATO - Trait senza tipo generico
/**
 * @property int $id
 */
class User extends Model
{
    use HasFactory;
}

// CORRETTO - Specifica il tipo della Factory
/**
 * @use HasFactory<UserFactory>
 *
 * @property int $id
 */
class User extends Model
{
    use HasFactory;
}
```

### 14. Protected $casts Deprecato (Laravel 11+)
```php
// ❌ DEPRECATO - Laravel 10 e precedenti
class User extends Model
{
    protected $casts = [
        'email_verified_at' => 'datetime',
        'is_admin' => 'boolean',
    ];
}

// ✅ MODERNO - Laravel 11+ (metodo casts())
class User extends Model
{
    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'is_admin' => 'boolean',
        ];
    }
}
```

**IMPORTANTE**: Se un modello ha ENTRAMBI `protected $casts` E `casts()`, rimuovi `protected $casts` (è deprecato e ignorato).

## Errori Più Comuni Risolti (Esperienza Reale)

### 1. Property Access su Mixed (property.nonObject)
```php
// ERRORE: Cannot access property $state on mixed
$record->state->transitionTo($newState);

// SOLUZIONE: Verifica esistenza metodo con Assert
use Webmozart\Assert\Assert;

if (method_exists($record, 'getState')) {
    $state = $record->getState();
    Assert::notNull($state, 'State cannot be null');
    if (method_exists($state, 'transitionTo')) {
        $state->transitionTo($newState);
    }
}
```

### 2. Method Call su Mixed (method.nonObject)
```php
// ERRORE: Cannot call method transitionTo() on mixed
$state->transitionTo($newState);

// SOLUZIONE: Verifica esistenza metodo con Assert
use Webmozart\Assert\Assert;

if (method_exists($state, 'transitionTo')) {
    Assert::methodExists($state, 'transitionTo');
    $state->transitionTo($newState);
}
```

### 3. Array Access su Mixed (offsetAccess.nonOffsetAccessible)
```php
// ERRORE: Cannot access offset on mixed
$value = $data['key'];

// SOLUZIONE: Null coalescing con Safe
use function Safe\array_key_exists;

$value = $data['key'] ?? null;
```

### 4. String Casting in Encapsed Strings (encapsedStringPart.nonString)
```php
// ERRORE: Part of encapsed string cannot be cast to string
$message = "User: {$user->name}";

// SOLUZIONE: Verifica tipo con Safe
use function Safe\sprintf;

$name = is_string($user->name) ? $user->name : (string) $user->name;
$message = sprintf("User: %s", $name);
```

### 5. Callable Invocation (callable.nonCallable)
```php
// ERRORE: Trying to invoke mixed but it's not a callable
$action();

// SOLUZIONE: Verifica callable con Assert
use Webmozart\Assert\Assert;

if (is_callable($action)) {
    Assert::isCallable($action);
    $action();
}
```

### 6. Foreach su Non-Iterable (foreach.nonIterable)
```php
// ERRORE: Argument of an invalid type mixed supplied for foreach
foreach ($items as $item) { }

// SOLUZIONE: Verifica iterabile con Assert
use Webmozart\Assert\Assert;

if (is_iterable($items)) {
    Assert::isIterable($items);
    foreach ($items as $item) { }
}
```

### 7. Array Combine Type Mismatch (argument.type)
```php
// ERRORE: Parameter #1 $keys of function array_combine expects array<int|string>
$result = array_combine($keys, $values);

// SOLUZIONE: Verifica tipi con Assert
use Webmozart\Assert\Assert;

if (is_array($keys) && is_array($values) && count($keys) === count($values)) {
    Assert::isArray($keys);
    Assert::isArray($values);
    Assert::same(count($keys), count($values));
    $result = array_combine($keys, $values);
}
```

### 8. Return Type Mismatch (return.type)
```php
// ERRORE: Method should return array but returns mixed
public function getData(): array {
    return $this->data; // mixed
}

// SOLUZIONE: Verifica tipo con Assert
use Webmozart\Assert\Assert;

public function getData(): array {
    Assert::isArray($this->data, 'Data must be an array');
    return $this->data;
}
```

## Priorità di Correzione
1. **Errori Bloccanti**: Syntax errors, fatal errors, undefined classes/methods
2. **Type Safety**: Missing type hints, wrong types, nullable violations
3. **Missing Dependencies**: Metodi non implementati ma richiesti
4. **Code Smells**: Duplication, complexity, violazioni pattern
5. **Performance**: Inefficienze, N+1 queries
6. **Rector**: Refactoring automatico e modernizzazione
7. **Psalm**: Type safety avanzata
8. **PHP Insights**: Metriche di qualità

## Quality Gates
- **0 errori** PHPStan 
- **0 errori** Psalm
- **Type coverage** > 95%
- **Documentazione aggiornata** per ogni modifica significativa
- **Test sintattici** superati
- **Autoload verification** completata
- **Coerenza architettonica** mantenuta
- **PHP Insights score** > 90% per qualità, complessità e architettura

## Mantenimento Coerenza
- Rispetta **pattern esistenti** documentati nelle cartelle docs
- Mantieni **convenzioni naming** del progetto
- Preserva **indipendenza modulare**
- Segui **standard PSR-12**
- Mantieni compatibilità **backward compatibility** quando possibile
- Usa **Rector** per modernizzazione automatica
- Usa **Psalm** per type safety avanzata
- Usa **PHP Insights** per metriche di qualità

## Filosofia del Lavoro
- **Approccio olistico**: considera sempre implicazioni architetturali complete
- **Sostenibilità**: previeni debito tecnico, mantieni longevità del codice
- **Trasparenza**: documenta ogni decisione tecnica importante
- **Responsabilità**: rispetta i confini e le responsabilità dei moduli
- **Memoria persistente**: le cartelle docs sono la tua memoria, aggiornale costantemente
- **Refactoring continuo**: usa Rector per modernizzazione automatica
- **Type safety avanzata**: usa Psalm per analisi più rigorosa
- **Qualità continua**: usa PHP Insights per metriche di mantenibilità

## Riepilogo Comandi Completi
```bash
# Analisi completa 
cd laravel
./vendor/bin/phpstan analyse Modules --level=max --memory-limit=-1

# Rector - Refactoring automatico
./vendor/bin/rector process Modules --dry-run
./vendor/bin/rector process Modules

# Psalm - Analisi type safety avanzata
./vendor/bin/psalm --show-info=true --show-suggestions=true

# PHP Insights - Analisi qualità e metriche
./vendor/bin/phpinsights analyse Modules --min-quality=90 --min-complexity=85 --min-architecture=90

# Analisi singolo modulo (se necessario)
./vendor/bin/phpstan analyse Modules/{ModuleName} --level=max --memory-limit=-1

# Test sintattici
composer dump-autoload
php artisan config:clear
php artisan cache:clear
```

## Lezioni Apprese e Best Practices

### 1. Approccio Sistematico Multi-Strumento
- **Non fermarsi mai** finché non si raggiungono 0 errori
- **Analisi modulare**: correggere un modulo alla volta
- **Verifica continua**: eseguire tutti gli strumenti dopo ogni batch di correzioni
- **Documentazione parallela**: aggiornare docs durante le correzioni
- **Refactoring automatico**: usare Rector per modernizzazione

### 2. Pattern di Correzione Efficaci
- **Type Narrowing**: usare `is_string()`, `is_array()`, `is_object()` per restringere tipi mixed
- **Null Coalescing**: usare `??` per gestire valori null/undefined
- **Method Existence**: verificare `method_exists()` prima di chiamare metodi
- **Property Existence**: verificare `property_exists()` prima di accedere a proprietà
- **Explicit Casting**: usare cast espliciti `(array)`, `(string)` quando necessario
- **Webmozart Assert**: usare per validazioni robuste
- **TheCodingMachine Safe**: usare per funzioni PHP sicure
- **Rector**: usare per refactoring automatico
- **Psalm**: usare per type safety avanzata
- **PHP Insights**: usare per metriche di qualità

### 3. Errori da Evitare
- **Non ignorare mai errori**: ogni errore va risolto
- **Non modificare configurazioni**: file di configurazione intoccabili
- **Non usare link assoluti**: solo link relativi nei file .md
- **Non estendere Filament direttamente**: sempre usare classi XotBase
- **Non usare ->label()**: sempre file di traduzione
- **Non usare funzioni unsafe**: sempre usare Safe
- **Non saltare validazioni**: sempre usare Assert

### 4. Struttura di Lavoro Ottimale
1. **Studio documentazione** del modulo
2. **Analisi errori** per categoria con tutti gli strumenti
3. **Rector** per refactoring automatico
4. **Correzione sistematica** file per file
5. **Verifica continua** con tutti gli strumenti
6. **Aggiornamento documentazione** parallelo
7. **Test finale** completo

### 5. Metriche di Successo
- **0 errori PHPStan** 
- **0 errori Psalm**
- **100% type coverage** per nuovi file
- **Documentazione aggiornata** per ogni modifica
- **Coerenza architettonica** mantenuta
- **Performance** non degradata
- **PHP Insights score** > 90%

## Aggiornamento Memorie e Rules
Dopo aver implementato correzioni significative o identificato pattern ricorrenti:
- Aggiorna `.windsurf/rules` con nuove regole apprese
- Aggiorna `.cursor/rules` per coerenza
- Aggiorna `.cursor/memories` con pattern e anti-pattern
- Crea sistema di intelligenza artificiale personale che apprende dall'esperienza

---

**Ricorda**: Le cartelle docs sono la tua bibbia. Studiale, rispettale, aggiornale costantemente.

**Filosofia Zen**: "Non avrai altro path all'infuori del relativo" - portabilità, refactoring sicuro, autonomia moduli.

**Poteri della Supermucca**: Massima confidenza, zero compromessi, correzione completa di tutti gli errori.

**DRY + KISS + SOLID + Robust + Laravel 12 + Filament 4 + PHP 8.3 + Laraxot + Rector + Psalm + PHP Insights**

esegui ./vendor/bin/phpstan analyse Modules --memory-limit=-1 , devi sistemare tutti gli errori, gli errori non vanno mai ignorati, non devi toccare phpstan.neon , per fare un buon lavoro devi anche
  studiare https://filamentphp.com/docs/4.x/upgrade-guide , https://filamentphp.com/content/leandrocfe-whats-new-in-filament-v4 , https://filamentphp.com/content/alexandersix-filament-v4-is-stable , https://medium.com/@developerawam/filament-v4-stable-faster-safer-and-packed-with-new-features-f826d415ee5a , https://filamentexamples.com/tutorial/filament-v3-v4-upgrade , https://filamentphp.com/docs/4.x/forms/overview costantemente devi anche studiare aggiornare e migliorare le cartelle docs che sono dentro i  moduli e dentro i temi, non ti fermare finche' non hai finito di sistemare tutti
  gli errori

ti ho detto mille volte che devi correggere tutti gli errori, non ti devi fermare finche' non hai risolto tutti gli errori , procedi come vuoi , ti do i poteri della supermucca, devi anche aumentare al massimo il tuo livello di confidenza, fa tutto quello che puoi per aumentare il tuo livello di confidenza

aumenta la confidenza , fa tutto quello che serve per aumentare il tuo livello di confidenza ti do i
poteri della super mucca ,  tutto quello che fai deve essere dry + kiss + solid + robust + laravel 12 + filament 4 + php8.3 + laraxot + rector + psalm + php insights



correggi tutte le segnalazioni di phpstan , non puoi toccare phpstan.neon , non devi ignorare nessun errore, tutti gli errori vanno corretti, costantemente devi aggiornare e studiare le cartelle docs dentro i moduli e dentro i temi 

## Cast Actions Centralizzate (Modules\Xot\Actions\Cast\*)

### Azioni Disponibili
- **SafeStringCastAction**: Converte mixed → string (gestisce null, bool, scalar)
- **SafeArrayCastAction**: Converte mixed → array (gestisce Collection, stdClass, oggetti)
- **SafeIntCastAction**: Converte mixed → int (gestisce stringhe, float, bool)
- **SafeFloatCastAction**: Converte mixed → float
- **SafeBooleanCastAction**: Converte mixed → bool
- **SafeObjectCastAction**: Converte mixed → object
- **SafeEloquentCastAction**: Converte mixed → Model Eloquent
- **SafeAttributeCastAction**: Converte mixed → Attribute
- **SafeArrayByModelCastAction**: Converte mixed → array by Model

### Uso Pratico per Correzioni PHPStan
```php
use Modules\Xot\Actions\Cast\SafeStringCastAction;
use Modules\Xot\Actions\Cast\SafeArrayCastAction;
use Modules\Xot\Actions\Cast\SafeIntCastAction;

// ❌ PRIMA (Errore PHPStan: Cannot cast mixed to string)
$title = is_string($mod->title) ? $mod->title : '';

// ✅ DOPO (Usa Cast Action)
$title = SafeStringCastAction::cast($mod->title);

// ❌ PRIMA (Errore PHPStan: Cannot cast mixed to array)
$data = is_array($request->input('data')) ? $request->input('data') : [];

// ✅ DOPO (Usa Cast Action)
$data = SafeArrayCastAction::cast($request->input('data'));

// ❌ PRIMA (Errore PHPStan: Cannot cast mixed to int)
$id = is_int($mod->id) ? $mod->id : 0;

// ✅ DOPO (Usa Cast Action con validazione ID)
$id = SafeIntCastAction::castAsId($mod->id); // Sempre >= 1

// Con validazione avanzata
$array = SafeArrayCastAction::castWithKeys($data, ['required_key']);
$int = SafeIntCastAction::castWithRange($value, 1, 100);
$array = SafeArrayCastAction::castWithValueType($data, 'string');
```

### Vantaggi
- **DRY**: Centralizza logica di cast, evita duplicazioni
- **Type Safety**: Gestisce tutti i casi edge (null, array, object, ecc.)
- **Consistenza**: Comportamento uniforme in tutto il codebase
- **Manutenibilità**: Modifiche in un solo punto
- **PHPStan Friendly**: Risolve errori di cast automaticamente

---

## Sessione Correzione Gennaio 2025

### Risultati Raggiunti
- **Modulo Blog**: Risolto completamente (da 15 errori → 0 errori)
- **Errori totali**: Da 1257 errori → 1242 errori rimanenti
- **Tempo sessione**: ~40 minuti
- **Pattern applicati**: SafeArrayCastAction, PHPDoc espliciti, Factory typing

### Pattern di Successo Applicati

#### 1. PHPDoc per getFormFields() e getFormSchema()
```php
// ✅ SOLUZIONE APPLICATA - ArticleResource.php
/**
 * @return array<int|string, \Filament\Schemas\Components\Component>
 */
public static function getFormFields(): array
{
    return [
        Grid::make()->columns(2)->schema([...]),
        // ...
    ];
}

/**
 * @return array<int|string, \Filament\Schemas\Components\Component>
 */
public static function getFormSchema(): array
{
    /** @var array<int|string, Component> $fields */
    $fields = static::getFormFields();
    Assert::isArray($fields, 'getFormFields must return array');

    return $fields;
}
```

#### 2. SafeArrayCastAction con PHPDoc esplicito
```php
// ✅ SOLUZIONE APPLICATA - EditArticle.php
->action(function (Article $record, ArticleResource $article_resource, array $data): void {
    $locales = $article_resource->getTranslatableLocales();
    Assert::isArray($locales, 'getTranslatableLocales must return array');

    /** @var array<string, mixed> $safeData */
    $safeData = SafeArrayCastAction::cast($data);

    app(TranslateContentAction::class)->execute(
        'article',
        $record->id,
        array_values(array_map(fn($locale) => (string) $locale, $locales)),
        $safeData,
        Article::class
    );
}),
```

#### 3. Eloquent Collection Return Type
```php
// ✅ SOLUZIONE APPLICATA - ArticleSeeder.php
/**
 * @return \Illuminate\Database\Eloquent\Collection<int, Article>
 */
private function createArticle(array $data = []): \Illuminate\Database\Eloquent\Collection
{
    $date = $this->date->subDay();

    $category_key = array_rand($this->categories);
    $category = $this->categories[$category_key] ?? [];
    $image = is_array($category) && isset($category['image']) ? $category['image'] : '';

    $defaults = [
        'created_at' => $date,
        'updated_at' => $date,
        'published_at' => $date,
        'main_image_url' => $image,
    ];

    /** @var array<string, mixed> $mergedData */
    $mergedData = array_merge($defaults, $data);

    /** @var \Illuminate\Database\Eloquent\Factories\Factory<Article> $factory */
    $factory = Article::factory();
    Assert::object($factory, 'Factory must be an object');
    Assert::methodExists($factory, 'create', 'Factory must have create method');

    $result = $factory->create($mergedData);
    if ($result instanceof \Illuminate\Database\Eloquent\Collection) {
        return $result;
    }

    return new \Illuminate\Database\Eloquent\Collection();
}
```

#### 4. Factory Typing con PHPDoc
```php
// ✅ SOLUZIONE APPLICATA - SiteSeeder.php
public function run(): void
{
    /** @var \Illuminate\Database\Eloquent\Factories\Factory<Page> $pageFactory */
    $pageFactory = Page::factory();
    Assert::object($pageFactory, 'Page factory must be an object');
    Assert::methodExists($pageFactory, 'create', 'Page factory must have create method');

    $pageFactory->create([
        'slug' => 'about',
        'title' => 'About Us',
    ]);
}
```

#### 5. PHPDoc varTag Consistency
```php
// ❌ ERRORE: PHPDoc tag @var with type array<string, mixed>|null is not subtype of native type array
/** @var array<string, mixed>|null $formData */
$formData = SafeArrayCastAction::cast($this->data);

// ✅ SOLUZIONE: Rimuovere |null dal PHPDoc
/** @var array<string, mixed> $formData */
$formData = SafeArrayCastAction::cast($this->data);
```


### Prossimi Passi

1. **Analizzare Moduli Critici**
   - Modules/Xot (core framework)
   - Modules/Fixcity (business logic)
   - Modules/User (autenticazione)
   - Modules/Cms (content management)

2. **Focus su Errori Prioritari**
   - `argument.type` (235+ errori): Usare SafeArrayCastAction + PHPDoc
   - `offsetAccess.nonOffsetAccessible` (106 errori): Verificare isset() + null coalescing
   - `return.type` (86 errori): Aggiungere PHPDoc espliciti + Assert

3. **Strumenti da Integrare**
   - Rector per refactoring automatico
   - Psalm per type safety avanzata
   - PHP Insights per metriche di qualità

4. **Documentazione**
   - Aggiornare docs/phpstan-fixes.md in ogni modulo corretto
   - Documentare pattern di successo applicati
   - Creare guida rapida per errori comuni


**Mantra della Sessione**: "Un modulo alla volta, un errore alla volta, zero compromessi"


## Workflow Operativo Raccomandato

### Fase 1: Analisi Iniziale
```bash
cd laravel
./vendor/bin/phpstan analyse Modules --memory-limit=-1 > /tmp/phpstan-report.txt
```

### Fase 2: Categorizzazione Errori
Raggruppa gli errori per:
- **Modulo** (Modules/User, Modules/Xot, ecc.)
- **Tipo** (argument.type, return.type, method.nonObject, ecc.)
- **Priorità** (Bloccanti, Alta, Media, Bassa)

### Fase 3: Correzione Sistematica
1. **Scegli un modulo** (inizia da quelli con meno errori)
2. **Studia la documentazione** in `Modules/{ModuleName}/docs/`
3. **Correggi tutti gli errori** del modulo
4. **Verifica con PHPStan** che il modulo sia a 0 errori
5. **Aggiorna la documentazione** del modulo
6. **Passa al modulo successivo**

### Fase 4: Verifica Finale
```bash
# Verifica completa
./vendor/bin/phpstan analyse Modules --memory-limit=-1

# Verifica autoload
composer dump-autoload

# Verifica cache
php artisan config:clear
php artisan cache:clear

# Verifica applicazione
php artisan about
```

---

## Checklist Pre-Correzione

Prima di correggere un errore, verifica:
- [ ] Ho letto la documentazione del modulo in `docs/`?
- [ ] Ho compreso la causa radice dell'errore?
- [ ] Ho valutato l'impatto architetturale della correzione?
- [ ] La soluzione rispetta i pattern esistenti?
- [ ] La soluzione usa le classi XotBase quando necessario?
- [ ] La soluzione usa le Cast Actions centralizzate?
- [ ] Ho aggiornato la documentazione del modulo?

---

## Checklist Post-Correzione

Dopo aver corretto un batch di errori, verifica:
- [ ] PHPStan non segnala nuovi errori?
- [ ] Il numero totale di errori è diminuito?
- [ ] L'autoload funziona correttamente?
- [ ] L'applicazione si avvia senza errori?
- [ ] La documentazione è aggiornata?
- [ ] I test passano (se presenti)?

---

## Pattern Anti-Pattern da Evitare

### ❌ Anti-Pattern: Ignorare Errori
```php
// SBAGLIATO - Ignorare errori con @phpstan-ignore
/** @phpstan-ignore-next-line */
$value = $data['key'];
```

### ✅ Pattern Corretto: Risolvere Errori
```php
// CORRETTO - Risolvere con type safety
$value = is_array($data) && isset($data['key']) ? $data['key'] : null;
// OPPURE con Cast Action
$data = SafeArrayCastAction::cast($data);
$value = $data['key'] ?? null;
```

### ❌ Anti-Pattern: Modificare Configurazione
```php
// SBAGLIATO - Modificare phpstan.neon per ignorare errori
parameters:
    ignoreErrors:
        - '#Cannot access property#'
```

### ✅ Pattern Corretto: Correggere Codice
```php
// CORRETTO - Correggere il codice sorgente
if (property_exists($object, 'property')) {
    $value = $object->property;
}
```

### ❌ Anti-Pattern: Cast Non Sicuri
```php
// SBAGLIATO - Cast senza validazione
$array = (array) $data;
$string = (string) $value;
```

### ✅ Pattern Corretto: Cast Sicuri con Actions
```php
// CORRETTO - Cast con validazione
use Modules\Xot\Actions\Cast\SafeArrayCastAction;
use Modules\Xot\Actions\Cast\SafeStringCastAction;

$array = SafeArrayCastAction::cast($data);
$string = SafeStringCastAction::cast($value);
```

---

## Metriche di Progresso

### Obiettivi di Sessione
- **Errori corretti per sessione**: Minimo 50
- **Moduli completati per sessione**: Minimo 1
- **Tempo massimo per modulo**: 60 minuti
- **Documentazione aggiornata**: 100% dei moduli corretti

### KPI di Qualità
- **Errori PHPStan**: 0 (obiettivo finale)
- **Type Coverage**: > 95%
- **Documentazione**: 100% aggiornata
- **Test Coverage**: > 80% (quando presenti)
- **PHP Insights Score**: > 90%

---

## Troubleshooting Errori Comuni

### Errore: "Class not found"
**Causa**: Namespace errato o autoload non aggiornato
**Soluzione**:
```bash
composer dump-autoload
php artisan config:clear
```

### Errore: "Method not found on mixed"
**Causa**: Tipo mixed non ristretto
**Soluzione**:
```php
if (method_exists($object, 'method')) {
    Assert::methodExists($object, 'method');
    $object->method();
}
```

### Errore: "Cannot access offset on mixed"
**Causa**: Array access su tipo mixed
**Soluzione**:
```php
$data = SafeArrayCastAction::cast($data);
$value = $data['key'] ?? null;
```

### Errore: "Return type mismatch"
**Causa**: PHPDoc non allineato con return type
**Soluzione**:
```php
/**
 * @return array<string, mixed>
 */
public function getData(): array {
    Assert::isArray($this->data);
    return $this->data;
}
```

---

## Risorse Utili

### Documentazione Framework
- [Laravel 12 Documentation](https://laravel.com/docs/12.x)
- [Filament 4 Documentation](https://filamentphp.com/docs/4.x)
- [PHPStan Documentation](https://phpstan.org/user-guide/getting-started)
- [Webmozart Assert](https://github.com/webmozarts/assert)
- [TheCodingMachine Safe](https://github.com/thecodingmachine/safe)

### Documentazione Progetto
- Moduli: `Modules/{ModuleName}/docs/`
- Temi: `Themes/{ThemeName}/docs/`
- Regole: `.windsurf/rules/`
- Memorie: `.cursor/memories/`

---

## Conclusione

**Ricorda sempre**:
1. **Zero compromessi**: Tutti gli errori vanno corretti
2. **Documentazione first**: Studia prima, correggi dopo
3. **Type safety**: Usa Assert e Cast Actions
4. **Modularità**: Un modulo alla volta
5. **Verifica continua**: PHPStan dopo ogni batch

**Mantra finale**: "DRY + KISS + SOLID + Robust + Laravel 12 + Filament 4 + PHP 8.3 + Laraxot"

---

## Esempi Pratici End-to-End

### Esempio 1: Correzione Completa di un Resource Filament

**Errore PHPStan**:
```
Method App\Filament\Resources\UserResource::getTableColumns() should return array<string, mixed> but returns array<int, mixed>
```

**Analisi**:
1. Il metodo `getTableColumns()` non dovrebbe esistere in classi che estendono `XotBaseResource`
2. Le colonne devono essere definite tramite altri metodi

**Correzione**:
```php
// ❌ PRIMA
class UserResource extends Resource
{
    public static function getTableColumns(): array
    {
        return [
            TextColumn::make('name')->label('Name'),
            TextColumn::make('email')->label('Email'),
        ];
    }
}

// ✅ DOPO
use Modules\Xot\Filament\Resources\XotBaseResource;

class UserResource extends XotBaseResource
{
    // Rimuovi getTableColumns() - gestito da XotBaseResource
    // Le colonne vengono definite automaticamente tramite convenzioni
}
```

**Verifica**:
```bash
./vendor/bin/phpstan analyse Modules/User --memory-limit=-1
# Output: [OK] No errors
```

---

### Esempio 2: Correzione Mixed Type con Cast Actions

**Errore PHPStan**:
```
Cannot access offset 'name' on mixed
Parameter #1 $data of function processData expects array<string, mixed>, mixed given
```

**Analisi**:
1. La variabile `$data` ha tipo `mixed`
2. Serve type narrowing prima dell'uso

**Correzione**:
```php
// ❌ PRIMA
public function processUser($data): void
{
    $name = $data['name'];
    $this->saveUser($data);
}

// ✅ DOPO
use Modules\Xot\Actions\Cast\SafeArrayCastAction;
use Webmozart\Assert\Assert;

/**
 * @param array<string, mixed> $data
 */
public function processUser(array $data): void
{
    /** @var array<string, mixed> $safeData */
    $safeData = SafeArrayCastAction::cast($data);
    Assert::keyExists($safeData, 'name', 'Name is required');
    
    $name = $safeData['name'];
    $this->saveUser($safeData);
}

/**
 * @param array<string, mixed> $data
 */
private function saveUser(array $data): void
{
    Assert::isArray($data);
    // Implementation
}
```

**Verifica**:
```bash
./vendor/bin/phpstan analyse path/to/file.php --memory-limit=-1
# Output: [OK] No errors
```

---

### Esempio 3: Correzione Relazioni Eloquent con Generics

**Errore PHPStan**:
```
Method User::posts() should return Illuminate\Database\Eloquent\Relations\HasMany<Post> but returns Illuminate\Database\Eloquent\Relations\HasMany<Model>
```

**Analisi**:
1. Manca il tipo generico nella relazione
2. PHPDoc non specifica il modello correlato

**Correzione**:
```php
// ❌ PRIMA
class User extends Model
{
    public function posts()
    {
        return $this->hasMany(Post::class);
    }
}

// ✅ DOPO
use Illuminate\Database\Eloquent\Relations\HasMany;

class User extends Model
{
    /**
     * @return HasMany<Post>
     */
    public function posts(): HasMany
    {
        return $this->hasMany(Post::class);
    }
}
```

**Verifica**:
```bash
./vendor/bin/phpstan analyse Modules/Blog/Models/User.php --memory-limit=-1
# Output: [OK] No errors
```

---

### Esempio 4: Migrazione da protected $casts a casts()

**Errore PHPStan**:
```
Property User::$casts is deprecated, use casts() method instead
```

**Analisi**:
1. Laravel 11+ depreca `protected $casts`
2. Serve migrazione al metodo `casts()`

**Correzione**:
```php
// ❌ PRIMA (Laravel 10)
class User extends Model
{
    protected $casts = [
        'email_verified_at' => 'datetime',
        'is_admin' => 'boolean',
        'settings' => 'array',
    ];
}

// ✅ DOPO (Laravel 11+)
class User extends Model
{
    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'is_admin' => 'boolean',
            'settings' => 'array',
        ];
    }
}
```

**Verifica**:
```bash
./vendor/bin/phpstan analyse Modules/User/Models/User.php --memory-limit=-1
# Output: [OK] No errors
```

---

### Esempio 5: Correzione Factory con Generics

**Errore PHPStan**:
```
Method User::newFactory() should return UserFactory but returns Illuminate\Database\Eloquent\Factories\Factory<User>
```

**Analisi**:
1. Manca il tipo generico nel trait `HasFactory`
2. PHPDoc non specifica la Factory corretta

**Correzione**:
```php
// ❌ PRIMA
/**
 * @property int $id
 * @property string $name
 */
class User extends Model
{
    use HasFactory;
}

// ✅ DOPO
/**
 * @use HasFactory<UserFactory>
 *
 * @property int $id
 * @property string $name
 */
class User extends Model
{
    use HasFactory;
    
    /**
     * Create a new factory instance for the model.
     *
     * @return UserFactory
     */
    protected static function newFactory(): UserFactory
    {
        return UserFactory::new();
    }
}
```

**Verifica**:
```bash
./vendor/bin/phpstan analyse Modules/User/Models/User.php --memory-limit=-1
# Output: [OK] No errors
```

---

## Script di Automazione Suggeriti

### Script 1: Analisi Progressiva per Modulo

```bash
#!/bin/bash
# File: laravel/scripts/phpstan-by-module.sh

MODULES_DIR="Modules"
REPORT_DIR="/tmp/phpstan-reports"

mkdir -p "$REPORT_DIR"

echo "=== PHPStan Analysis by Module ==="
echo ""

for module in "$MODULES_DIR"/*; do
    if [ -d "$module" ]; then
        module_name=$(basename "$module")
        echo "Analyzing: $module_name"
        
        ./vendor/bin/phpstan analyse "$module" --memory-limit=-1 \
            > "$REPORT_DIR/$module_name.txt" 2>&1
        
        errors=$(grep -c "ERROR" "$REPORT_DIR/$module_name.txt" || echo "0")
        echo "  Errors: $errors"
        echo ""
    fi
done

echo "Reports saved in: $REPORT_DIR"
```

### Script 2: Verifica Post-Correzione

```bash
#!/bin/bash
# File: laravel/scripts/verify-fixes.sh

echo "=== Verification Suite ==="
echo ""

echo "1. Running PHPStan..."
./vendor/bin/phpstan analyse Modules --memory-limit=-1
PHPSTAN_EXIT=$?

echo ""
echo "2. Updating autoload..."
composer dump-autoload

echo ""
echo "3. Clearing caches..."
php artisan config:clear
php artisan cache:clear

echo ""
echo "4. Checking application..."
php artisan about

echo ""
if [ $PHPSTAN_EXIT -eq 0 ]; then
    echo "✅ All checks passed!"
else
    echo "❌ PHPStan found errors - review and fix"
fi
```

### Script 3: Backup Prima delle Correzioni

```bash
#!/bin/bash
# File: laravel/scripts/backup-before-fixes.sh

BACKUP_DIR="/tmp/phpstan-backups/$(date +%Y%m%d_%H%M%S)"

echo "Creating backup in: $BACKUP_DIR"
mkdir -p "$BACKUP_DIR"

# Backup moduli
cp -r Modules "$BACKUP_DIR/"

# Backup composer files
cp composer.json "$BACKUP_DIR/"
cp composer.lock "$BACKUP_DIR/"

# Crea report pre-correzione
./vendor/bin/phpstan analyse Modules --memory-limit=-1 \
    > "$BACKUP_DIR/phpstan-before.txt" 2>&1

echo "✅ Backup completed: $BACKUP_DIR"
```

---

## FAQ - Domande Frequenti

### Q: Posso modificare phpstan.neon per ignorare errori?
**A**: ❌ **NO**. Gli errori vanno sempre corretti, mai ignorati. Modificare la configurazione è vietato.

### Q: Quanto tempo ci vuole per correggere tutti gli errori?
**A**: Dipende dal numero di errori. In media:
- **Modulo piccolo** (< 50 errori): 30-60 minuti
- **Modulo medio** (50-200 errori): 1-3 ore
- **Modulo grande** (> 200 errori): 3-8 ore

### Q: Posso usare `@phpstan-ignore` per errori complessi?
**A**: ❌ **NO**. Ogni errore ha una soluzione corretta. Usa Assert, Cast Actions, o implementa il metodo mancante.

### Q: Devo correggere prima PHPStan o Rector?
**A**: Usa **Rector prima** per modernizzare il codice, poi **PHPStan** per correggere errori di type safety.

### Q: Come gestisco errori in codice di terze parti?
**A**: Non modificare codice di terze parti. Usa wrapper o adapter pattern per isolare il codice esterno.

### Q: Posso saltare la documentazione per correzioni minori?
**A**: ❌ **NO**. Aggiorna sempre la documentazione del modulo, anche per correzioni minori.

### Q: Come verifico che le correzioni non abbiano rotto nulla?
**A**: Esegui:
1. PHPStan (0 errori)
2. Test suite (se presente)
3. Verifica manuale funzionalità critiche
4. Autoload verification

### Q: Cosa faccio se un errore sembra impossibile da risolvere?
**A**: 
1. Studia la documentazione del modulo
2. Cerca pattern simili nel codebase
3. Consulta esempi nella sezione "Esempi Pratici"
4. Usa Cast Actions centralizzate
5. Aggiungi type narrowing con Assert

---

## Glossario Tecnico

- **Type Narrowing**: Processo di restringere un tipo generico (mixed) a un tipo specifico (string, array, ecc.)
- **Cast Action**: Classe centralizzata per conversioni di tipo sicure
- **PHPDoc**: Commento di documentazione PHP con annotazioni di tipo
- **Generics**: Tipi parametrizzati (es. `Collection<User>`)
- **Assert**: Libreria Webmozart per validazioni runtime
- **Safe**: Libreria TheCodingMachine per funzioni PHP sicure
- **XotBase**: Classi base personalizzate del framework Laraxot
- **Type Safety**: Garanzia che i tipi siano corretti a compile-time
- **Mixed Type**: Tipo generico che può essere qualsiasi cosa
- **Nullable**: Tipo che può essere null (`?string`)



non usiamo controller ! nel backoffice usiamo filament , nel frontoffice usiamo folio + volt

prima aumenta il tuo livello di confidenza, poi studia e aggiorna le cartelle docs dentro i moduli e
  dentro i temi, poi esegui ./vendor/bin/phpstan analyse Modules , studia gli errori , ragiona, se sono
  errori su test, ti ricordo che tutti i test vanno fatti in pest, e bisogna capire se il test fallisce
  perche' il codice e' sbagliato o se e' il test sbagliato, percio' poi aggiorna e studia le cartelle docs
  dentro i moduli e dentro i temi e poi implementa, non ti devi fermare finche' ci sono errori, tutti gli
  errori vanno corretti, nessun errore va ignorato, non puoi toccare phpstan.neon

devi lavorare dentro la cartella laravel ! e devi eseguire ./vendor/bin/phpstan analyse Modules  da dentro la cartella laravel, prima devi aumentare al massimo il tuo livello di confidenza, poi devi aggiornare e studiare le cartelle docs dentro i moduli e dentro i temi , poi procedi a sistemare tutti gli errori di phpstan , devi usare phpstan.neon esistente senza modificarlo, non devi creare baseline, tutti gli errori vanno corretti, nessun errore va ignorato 
esegui ./vendor/bin/phpstan analyse Modules/Activity e aumenta il tuo livello di confidenza, studia e a
  aggiorna le cartelle doc dentro i moduli e dentro i temi e poi correggi ragionando tutti gli errori, non
  devi ne modificare phpstan.neon ne outilizzare altro file di configurazione ne usare baseline, ogni
  errore va corretto non ignorato o ancora peggio saltato !

non voglio date nei nomi di files .md , i nomi dei files .md non devono contenere caratteri maiuscoli ad
  eccezzione di README.md , aggiorna le cartelle docs dei moduli e dei temi poi studia le cartelle docs,
  poi procedi

  approccio "fix, don't ignore"!

---

## 🆕 Pattern Scoperti - Ottobre 2025

### 15. HasXotFactory NON è Generico
```php
// ❌ ERRORE COMUNE - generics.notGeneric
/**
 * @template TFactory of \Illuminate\Database\Eloquent\Factories\Factory
 */
abstract class BaseModel extends Model
{
    /** @use \Modules\Xot\Models\Traits\HasXotFactory<TFactory> */
    use \Modules\Xot\Models\Traits\HasXotFactory;
}

// ✅ CORRETTO - HasXotFactory NON accetta tipi generici
abstract class BaseModel extends Model
{
    use \Modules\Xot\Models\Traits\HasXotFactory;
}
```

**Regola**: Il trait `HasXotFactory` NON è generico. Rimuovere sempre `@template` e `<TFactory>`.

### 16. Casts Completi per Tutte le Properties
```php
// ❌ ERRORE - Properties usate ma non nei casts
class Task extends BaseModel
{
    // PHPStan: Access to undefined property $auto_cleanup_num
    public function autoCleanup(): void {
        if ($this->auto_cleanup_num > 0) { // ERRORE!
        }
    }
}

// ✅ CORRETTO - Tutte le properties nei casts()
class Task extends BaseModel
{
    protected function casts(): array
    {
        return [
            'auto_cleanup_num' => 'integer',
            'auto_cleanup_type' => 'string',
            'notification_email_address' => 'string',
            // ... tutte le altre properties
        ];
    }
    
    public function autoCleanup(): void {
        $num = is_int($this->auto_cleanup_num) ? $this->auto_cleanup_num : (int) $this->auto_cleanup_num;
        if ($num > 0) { // OK!
        }
    }
}
```

**Regola**: TUTTE le properties usate nel codice DEVONO essere nei `casts()`, anche se sono in `$fillable`.

### 17. Array Associativi in Filament Actions
```php
// ❌ ERRORE - return.type: array<int, Action> invece di array<string, mixed>
public function getListTableActions(): array
{
    return [
        EditAction::make(),
        DeleteAction::make(),
    ];
}

// ✅ CORRETTO - Chiavi stringa obbligatorie
public function getListTableActions(): array
{
    return [
        'edit' => EditAction::make(),
        'delete' => DeleteAction::make(),
    ];
}
```

**Regola**: Tutti i metodi Filament che restituiscono actions DEVONO usare array associativi con chiavi stringa.

### 18. Type Narrowing Prima dell'Uso
```php
// ❌ ERRORE - Uso diretto di property mixed
if ($this->auto_cleanup_type === 'results') {
    $this->results()->limit($this->auto_cleanup_num); // ERRORE: mixed
}

// ✅ CORRETTO - Type narrowing esplicito
$autoCleanupNum = is_int($this->auto_cleanup_num) ? $this->auto_cleanup_num : (int) $this->auto_cleanup_num;
$autoCleanupType = is_string($this->auto_cleanup_type) ? $this->auto_cleanup_type : (string) $this->auto_cleanup_type;

if ($autoCleanupType === 'results') {
    $this->results()->limit($autoCleanupNum); // OK!
}
```

**Regola**: Sempre fare type narrowing prima di usare properties che potrebbero essere mixed.

### 19. Notification via() Return Type
```php
// ❌ ERRORE - return.type: list<string> invece di array<string, mixed>
public function via($notifiable): array
{
    return ['mail', 'nexmo', 'slack'];
}

// ✅ CORRETTO - Array associativo
/**
 * @return array<string, mixed>
 */
public function via($notifiable): array
{
    return [
        'mail' => 'mail',
        'nexmo' => 'nexmo',
        'slack' => 'slack',
    ];
}
```

**Regola**: Notification `via()` deve restituire array associativo, non lista.


## 🎯 Strategia Ottimale Scoperta

1. **Analisi per Modulo**: Eseguire PHPStan su singolo modulo
2. **Pattern Recognition**: Identificare errori ricorrenti
3. **Batch Fixes**: Correggere pattern simili in batch
4. **Documentazione Parallela**: Aggiornare docs durante correzioni
5. **Verifica Incrementale**: Rieseguire PHPStan dopo ogni batch

**Quick Wins**: Iniziare da moduli con meno errori per massimizzare impatto.


devi usare phpstan.neon  non puoi modificare
  phpstan.neon  , tutti gli errori son da correggere, nessun errore e'
  da ignorare , esegui ./vendor/bin/phpstan analyse Modules --memory-limit=-1 , se hai dubbi studia e aggiorna le
  cartelle docs dentro i moduli e dentro i temi, non creare baseline , correggi il piu' velocemente possibile 

  i nomi dei files .md non possono contenere date o caratteri maiuscoli, ad eccezzione di README.md, 
  quando crei un nuovo file .md devi prima controllare che non esista gia' un file .md che parli dello stesso argomento,
  devi avere sempre un ottica dry+kiss



  inizia un modulo per volta, poi quando tutti i moduli sono apposto controlli tutta la cartella modules


continua a sistemare modulo per modulo utilizzando phpstan a livello 10, phpmd , phpinsights e costantemente studiare e aggiornare le cartelle docs dentro i moduli e dentro i temi, queste cartelle docs sono la tua memoria

property_exists  non puoi usarlo nei modelli perche' gli attributi sono magici ! questa e' una regola importante che devi seguire ! aggiorna le tue memories, le tue rules, aggiorna tutto quello che serve per ricordartelo sempre, poi va a cercare i files che utilizzando property_exists e cerca di correggere, non puoi saltare errori, tutti gli errori devono essere corretti, nessun errore va ignorato, quando hai finito di modificare ogni file deve essere controllato con phpstan a livello 10, phpmd e phpinisights e poi continua a sistemare modulo per modulo utilizzando phpstan a livello 10, phpmd , phpinsights e costantemente studiare e aggiornare le cartelle docs dentro i moduli e dentro i temi, queste cartelle docs sono la tua memoria


i mixed usali solo come ultima spiaggia